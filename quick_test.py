#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
AËÇ°ÈáèÂåñÁ≥ªÁªüÂø´ÈÄüÊµãËØï - quick_test.py
ÂäüËÉΩÔºö‰ΩøÁî®Â∞ëÈáèÊï∞ÊçÆÂø´ÈÄüÈ™åËØÅÁ≥ªÁªüÂäüËÉΩ
‰ΩúËÄÖÔºöClaude
Êó∂Èó¥Ôºö2025Âπ¥
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import pickle
import os
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

# ËÆæÁΩÆ‰∏≠ÊñáÂ≠ó‰Ωì - ‰øÆÂ§ç‰π±Á†ÅÈóÆÈ¢ò
import matplotlib
import platform

# Ê†πÊçÆ‰∏çÂêåÊìç‰ΩúÁ≥ªÁªüËÆæÁΩÆÂ≠ó‰Ωì
system = platform.system()
if system == 'Darwin':  # macOS
    plt.rcParams['font.sans-serif'] = ['Arial Unicode MS', 'STHeiti', 'SimHei']
elif system == 'Windows':  # Windows
    plt.rcParams['font.sans-serif'] = ['Microsoft YaHei', 'SimHei', 'FangSong']
else:  # Linux
    plt.rcParams['font.sans-serif'] = ['DejaVu Sans', 'WenQuanYi Micro Hei']

plt.rcParams['axes.unicode_minus'] = False

# Â¶ÇÊûúËøòÊòØÊúâÈóÆÈ¢òÔºå‰ΩøÁî®Ëã±ÊñáÊ†áÈ¢ò
USE_ENGLISH_LABELS = True  # ËÆæ‰∏∫True‰ΩøÁî®Ëã±ÊñáÔºåFalse‰ΩøÁî®‰∏≠Êñá

# =============================================================================
# ÈÖçÁΩÆÂèÇÊï∞
# =============================================================================

class QuickTestConfig:
    """Âø´ÈÄüÊµãËØïÈÖçÁΩÆ"""
    # ÁºìÂ≠òÁõÆÂΩï
    CACHE_DIR = './data_cache/'
    STOCK_POOL_FILE = 'stock_pool.pkl'
    PRICE_DATA_FILE = 'price_data.pkl'
    
    # ÊµãËØïÂèÇÊï∞
    INITIAL_CAPITAL = 10000
    MAX_POSITIONS = 6
    TEST_STOCK_COUNT = 20  # Âè™ÊµãËØï20Âè™ËÇ°Á•®
    
    # ÊµãËØïÊó∂Èó¥ËåÉÂõ¥ÔºàÁº©Áü≠Ôºâ
    START_DATE = '2023-01-01'
    END_DATE = '2023-12-31'
    
    # ‰∫§ÊòìÊàêÊú¨
    COMMISSION_RATE = 0.0003
    STAMP_TAX = 0.001
    MIN_COMMISSION = 5

config = QuickTestConfig()

# =============================================================================
# Êï∞ÊçÆÂä†ËΩΩÂô®
# =============================================================================

class QuickDataLoader:
    """Âø´ÈÄüÊï∞ÊçÆÂä†ËΩΩÂô®"""
    
    def __init__(self, config):
        self.config = config
    
    def load_test_data(self):
        """Âä†ËΩΩÊµãËØïÊï∞ÊçÆ"""
        print("üîç Âä†ËΩΩÊµãËØïÊï∞ÊçÆ...")
        
        # Ê£ÄÊü•ÁºìÂ≠òÊñá‰ª∂ÊòØÂê¶Â≠òÂú®
        stock_pool_file = os.path.join(self.config.CACHE_DIR, self.config.STOCK_POOL_FILE)
        price_data_file = os.path.join(self.config.CACHE_DIR, self.config.PRICE_DATA_FILE)
        
        if not os.path.exists(stock_pool_file) or not os.path.exists(price_data_file):
            print("‚ùå Êú™ÊâæÂà∞ÁºìÂ≠òÊï∞ÊçÆÊñá‰ª∂")
            print("üí° ËØ∑ÂÖàËøêË°å setup_data.py Ëé∑ÂèñÊï∞ÊçÆ")
            return None, None
        
        try:
            # Âä†ËΩΩËÇ°Á•®Ê±†
            with open(stock_pool_file, 'rb') as f:
                stock_pool = pickle.load(f)
            print(f"‚úÖ Âä†ËΩΩËÇ°Á•®Ê±†: {len(stock_pool)}Âè™ËÇ°Á•®")
            
            # Âä†ËΩΩ‰ª∑Ê†ºÊï∞ÊçÆ
            with open(price_data_file, 'rb') as f:
                price_data = pickle.load(f)
            print(f"‚úÖ Âä†ËΩΩ‰ª∑Ê†ºÊï∞ÊçÆ: {len(price_data)}Âè™ËÇ°Á•®")
            
            # ÈÄâÊã©ÊµãËØïÁî®ÁöÑËÇ°Á•®ÔºàÈöèÊú∫ÈÄâÊã©Ôºâ
            available_stocks = []
            for _, stock in stock_pool.iterrows():
                if stock['code'] in price_data and not price_data[stock['code']].empty:
                    available_stocks.append(stock)
                    if len(available_stocks) >= self.config.TEST_STOCK_COUNT:
                        break
            
            if len(available_stocks) < 5:
                print("‚ùå ÂèØÁî®ÊµãËØïÊï∞ÊçÆ‰∏çË∂≥")
                return None, None
            
            test_stock_pool = pd.DataFrame(available_stocks)
            test_price_data = {stock['code']: price_data[stock['code']] 
                             for stock in available_stocks}
            
            print(f"‚úÖ ÊµãËØïÊï∞ÊçÆÂáÜÂ§áÂÆåÊàê: {len(test_stock_pool)}Âè™ËÇ°Á•®")
            
            return test_stock_pool, test_price_data
            
        except Exception as e:
            print(f"‚ùå Âä†ËΩΩÊï∞ÊçÆÂ§±Ë¥•: {e}")
            return None, None

# =============================================================================
# ÁÆÄÂåñÊäÄÊúØÂàÜÊûê
# =============================================================================

class SimpleTechnicalAnalyzer:
    """ÁÆÄÂåñÊäÄÊúØÂàÜÊûêÂô®"""
    
    @staticmethod
    def calculate_indicators(price_data):
        """ËÆ°ÁÆóÊäÄÊúØÊåáÊ†á"""
        if len(price_data) < 30:
            return None
        
        close = price_data['close']
        
        # ÁßªÂä®Âπ≥ÂùáÁ∫ø
        ma5 = close.rolling(5).mean()
        ma20 = close.rolling(20).mean()
        
        # RSI
        delta = close.diff()
        gain = delta.where(delta > 0, 0).rolling(14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(14).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        
        # Âä®Èáè
        momentum = close / close.shift(10) - 1
        
        return {
            'current_price': close.iloc[-1],
            'ma5': ma5.iloc[-1],
            'ma20': ma20.iloc[-1],
            'rsi': rsi.iloc[-1],
            'momentum': momentum.iloc[-1]
        }

# =============================================================================
# ÁÆÄÂåñÈÄâËÇ°Á≠ñÁï•
# =============================================================================

class QuickStockSelector:
    """Âø´ÈÄüÈÄâËÇ°Á≠ñÁï•"""
    
    def __init__(self, config):
        self.config = config
        self.analyzer = SimpleTechnicalAnalyzer()
    
    def select_stocks(self, stock_pool, price_data, date):
        """ÈÄâËÇ°"""
        print(f"üìä ÊâßË°åÈÄâËÇ° - {date}")
        
        candidates = []
        
        for _, stock in stock_pool.iterrows():
            stock_code = stock['code']
            
            if stock_code not in price_data:
                continue
            
            # Ëé∑ÂèñÂà∞ÊåáÂÆöÊó•ÊúüÁöÑÊï∞ÊçÆ
            stock_price_data = price_data[stock_code]
            date_filtered = stock_price_data[stock_price_data.index <= date]
            
            if len(date_filtered) < 30:
                continue
            
            # ËÆ°ÁÆóÊäÄÊúØÊåáÊ†á
            indicators = self.analyzer.calculate_indicators(date_filtered)
            if indicators is None:
                continue
            
            # ÁÆÄÂåñÈÄâËÇ°Êù°‰ª∂
            if (indicators['current_price'] > indicators['ma20'] and
                indicators['ma5'] > indicators['ma20'] and
                20 <= indicators['rsi'] <= 80 and
                indicators['momentum'] > -0.2):
                
                score = (
                    indicators['momentum'] * 50 +
                    (indicators['current_price'] / indicators['ma20'] - 1) * 30 +
                    (70 - abs(indicators['rsi'] - 50)) * 0.5
                )
                
                candidates.append({
                    'code': stock_code,
                    'name': stock['name'],
                    'score': score,
                    'price': indicators['current_price'],
                    'rsi': indicators['rsi'],  
                    'momentum': indicators['momentum']
                })
        
        if candidates:
            candidates_df = pd.DataFrame(candidates)
            selected = candidates_df.nlargest(self.config.MAX_POSITIONS, 'score')
            
            print(f"‚úÖ ÈÄâÂá∫ {len(selected)} Âè™ËÇ°Á•®:")
            for _, stock in selected.iterrows():
                print(f"  {stock['code']} {stock['name']:<8} ËØÑÂàÜ:{stock['score']:.1f}")
            
            return selected
        else:
            print("‚ö†Ô∏è Êú™ÊâæÂà∞Á¨¶ÂêàÊù°‰ª∂ÁöÑËÇ°Á•®")
            return pd.DataFrame()

# =============================================================================
# ÁÆÄÂåñÂõûÊµãÂºïÊìé
# =============================================================================

class QuickBacktestEngine:
    """Âø´ÈÄüÂõûÊµãÂºïÊìé"""
    
    def __init__(self, config):
        self.config = config
        self.selector = QuickStockSelector(config)
        
        # ‰∫§ÊòìÁä∂ÊÄÅ
        self.cash = config.INITIAL_CAPITAL
        self.positions = {}
        self.portfolio_history = []
        self.trades = []
    
    def calculate_cost(self, amount, is_sell=False):
        """ËÆ°ÁÆó‰∫§ÊòìÊàêÊú¨"""
        commission = max(amount * self.config.COMMISSION_RATE, self.config.MIN_COMMISSION)
        stamp_tax = amount * self.config.STAMP_TAX if is_sell else 0
        return commission + stamp_tax
    
    def execute_trade(self, action, code, price, shares, date):
        """ÊâßË°å‰∫§Êòì"""
        amount = shares * price
        cost = self.calculate_cost(amount, action == 'sell')
        
        if action == 'buy':
            total_cost = amount + cost
            if total_cost <= self.cash:
                self.cash -= total_cost
                self.positions[code] = self.positions.get(code, 0) + shares
                self.trades.append({
                    'date': date, 'action': 'buy', 'code': code,
                    'shares': shares, 'price': price, 'cost': cost
                })
                return True
        else:  # sell
            if code in self.positions and self.positions[code] >= shares:
                net_amount = amount - cost
                self.cash += net_amount
                self.positions[code] -= shares
                if self.positions[code] == 0:
                    del self.positions[code]
                self.trades.append({
                    'date': date, 'action': 'sell', 'code': code,
                    'shares': shares, 'price': price, 'cost': cost
                })
                return True
        return False
    
    def get_portfolio_value(self, date, price_data):
        """ËÆ°ÁÆóÁªÑÂêà‰ª∑ÂÄº"""
        total_value = self.cash
        
        for code, shares in self.positions.items():
            if code in price_data:
                stock_data = price_data[code]
                date_data = stock_data[stock_data.index <= date]
                if not date_data.empty:
                    current_price = date_data['close'].iloc[-1]
                    total_value += shares * current_price
        
        return total_value
    
    def rebalance(self, date, stock_pool, price_data):
        """ÊâßË°åË∞É‰ªì"""
        print(f"\nüìÖ ÊâßË°åË∞É‰ªì - {date}")
        
        # ÈÄâËÇ°
        selected_stocks = self.selector.select_stocks(stock_pool, price_data, date)
        
        if selected_stocks.empty:
            print("‚ùå Êó†ÈÄâËÇ°ÁªìÊûúÔºåË∑≥ËøáË∞É‰ªì")
            return
        
        # Ê∏Ö‰ªì‰∏çÂú®Êñ∞ÈÄâËÇ°‰∏≠ÁöÑËÇ°Á•®
        current_codes = set(self.positions.keys())
        selected_codes = set(selected_stocks['code'])
        to_sell = current_codes - selected_codes
        
        for code in to_sell:
            shares = self.positions[code]
            stock_data = price_data[code]
            date_data = stock_data[stock_data.index <= date]
            if not date_data.empty:
                sell_price = date_data['close'].iloc[-1]
                if self.execute_trade('sell', code, sell_price, shares, date):
                    print(f"  üì§ ÂçñÂá∫ {code} {shares}ËÇ° @{sell_price:.2f}")
        
        # ËÆ°ÁÆóÁõÆÊ†á‰ªì‰ΩçÂπ∂‰π∞ÂÖ•
        portfolio_value = self.get_portfolio_value(date, price_data)
        target_value_per_stock = portfolio_value * 0.9 / len(selected_stocks)
        
        for _, stock in selected_stocks.iterrows():
            code = stock['code']
            target_price = stock['price']
            
            target_shares = int(target_value_per_stock // (target_price * 100)) * 100
            current_shares = self.positions.get(code, 0)
            
            if target_shares > current_shares:
                shares_to_buy = target_shares - current_shares
                if self.execute_trade('buy', code, target_price, shares_to_buy, date):
                    print(f"  üì• ‰π∞ÂÖ• {code} {stock['name']} {shares_to_buy}ËÇ° @{target_price:.2f}")
        
        # ËÆ∞ÂΩïÁªÑÂêàÁä∂ÊÄÅ
        final_value = self.get_portfolio_value(date, price_data)
        self.portfolio_history.append({
            'date': pd.to_datetime(date),
            'value': final_value,
            'cash': self.cash,
            'positions': len(self.positions)
        })
        
        print(f"  üí∞ ÁªÑÂêà‰ª∑ÂÄº: {final_value:.0f}ÂÖÉ, Áé∞Èáë: {self.cash:.0f}ÂÖÉ")
    
    def run_backtest(self, stock_pool, price_data):
        """ËøêË°åÂø´ÈÄüÂõûÊµã"""
        print("üöÄ ÂºÄÂßãÂø´ÈÄüÂõûÊµã")
        print("="*40)
        
        # ÁîüÊàêÂ≠£Â∫¶Ë∞É‰ªìÊó•Êúü
        rebalance_dates = pd.date_range(
            start=self.config.START_DATE,
            end=self.config.END_DATE,
            freq='QS'
        )
        
        print(f"ÂõûÊµãÂë®Êúü: {len(rebalance_dates)}‰∏™Â≠£Â∫¶")
        
        for i, date in enumerate(rebalance_dates):
            date_str = date.strftime('%Y-%m-%d')
            print(f"\n[{i+1}/{len(rebalance_dates)}] {date_str}")
            self.rebalance(date_str, stock_pool, price_data)
        
        print(f"\n‚úÖ Âø´ÈÄüÂõûÊµãÂÆåÊàêÔºÅÂÖ±ÊâßË°å{len(self.trades)}Á¨î‰∫§Êòì")

# =============================================================================
# ÁªìÊûúÂàÜÊûê
# =============================================================================

class QuickResultAnalyzer:
    """Âø´ÈÄüÁªìÊûúÂàÜÊûê"""
    
    def __init__(self, backtest_engine):
        self.engine = backtest_engine
        self.history_df = pd.DataFrame(backtest_engine.portfolio_history)
    
    def calculate_metrics(self):
        """ËÆ°ÁÆóÁª©ÊïàÊåáÊ†á"""
        if self.history_df.empty:
            return {}
        
        initial = self.engine.config.INITIAL_CAPITAL
        final = self.history_df['value'].iloc[-1]
        
        total_return = (final - initial) / initial
        
        # Âπ¥ÂåñÊî∂ÁõäÁéá
        days = (self.history_df['date'].iloc[-1] - self.history_df['date'].iloc[0]).days
        annual_return = (1 + total_return) ** (365 / days) - 1
        
        # ÊúÄÂ§ßÂõûÊí§
        peak = self.history_df['value'].expanding().max()
        drawdown = (self.history_df['value'] - peak) / peak
        max_drawdown = drawdown.min()
        
        return {
            'initial_value': initial,
            'final_value': final,
            'total_return': total_return,
            'annual_return': annual_return,
            'max_drawdown': max_drawdown,
            'trade_count': len(self.engine.trades)
        }
    
    def plot_results(self):
        """ÁªòÂà∂ÁªìÊûúÂõæË°®"""
        if self.history_df.empty:
            print("Êó†Êï∞ÊçÆÂèØÁªòÂà∂")
            return
        
        fig, axes = plt.subplots(2, 2, figsize=(12, 8))
        
        # Ê†πÊçÆËÆæÁΩÆÈÄâÊã©Ê†áÈ¢òËØ≠Ë®Ä
        if USE_ENGLISH_LABELS:
            titles = ['Portfolio Value', 'Cumulative Return', 'Cash Ratio', 'Position Count']
            ylabels = ['Value (CNY)', 'Return (%)', 'Ratio (%)', 'Stock Count']
        else:
            titles = ['ËµÑ‰∫ßÂáÄÂÄºÊõ≤Á∫ø', 'Á¥ØËÆ°Êî∂ÁõäÁéá', 'Áé∞ÈáëÂç†ÊØî', 'ÊåÅ‰ªìÊï∞Èáè']
            ylabels = ['‰ª∑ÂÄº(ÂÖÉ)', 'Êî∂ÁõäÁéá(%)', 'Âç†ÊØî(%)', 'ËÇ°Á•®Êï∞Èáè']
        
        # ÂáÄÂÄºÊõ≤Á∫ø
        axes[0,0].plot(self.history_df['date'], self.history_df['value'], 'b-', linewidth=2)
        axes[0,0].axhline(self.engine.config.INITIAL_CAPITAL, color='r', linestyle='--', alpha=0.7)
        axes[0,0].set_title(titles[0])
        axes[0,0].set_ylabel(ylabels[0])
        axes[0,0].grid(True, alpha=0.3)
        
        # Êî∂ÁõäÁéá
        returns = (self.history_df['value'] / self.engine.config.INITIAL_CAPITAL - 1) * 100
        axes[0,1].plot(self.history_df['date'], returns, 'g-', linewidth=2)
        axes[0,1].axhline(0, color='r', linestyle='--', alpha=0.7)
        axes[0,1].set_title(titles[1])
        axes[0,1].set_ylabel(ylabels[1])
        axes[0,1].grid(True, alpha=0.3)
        
        # Áé∞ÈáëÂç†ÊØî
        cash_pct = self.history_df['cash'] / self.history_df['value'] * 100
        axes[1,0].plot(self.history_df['date'], cash_pct, 'orange', linewidth=2)
        axes[1,0].set_title(titles[2])
        axes[1,0].set_ylabel(ylabels[2])
        axes[1,0].grid(True, alpha=0.3)
        
        # ÊåÅ‰ªìÊï∞Èáè
        axes[1,1].plot(self.history_df['date'], self.history_df['positions'], 
                      'purple', marker='o', linewidth=2)
        axes[1,1].set_title(titles[3])
        axes[1,1].set_ylabel(ylabels[3])
        axes[1,1].grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.show()
    
    def print_summary(self):
        """ÊâìÂç∞ÁªìÊûúÊÄªÁªì"""
        metrics = self.calculate_metrics()
        
        print("\n" + "="*50)
        print("üìä Âø´ÈÄüÊµãËØïÁªìÊûúÊÄªÁªì")
        print("="*50)
        
        if metrics:
            print(f"üí∞ ÂàùÂßãËµÑÈáë: {metrics['initial_value']:,.0f} ÂÖÉ")
            print(f"üíé ÊúÄÁªà‰ª∑ÂÄº: {metrics['final_value']:,.0f} ÂÖÉ")
            print(f"üìà ÊÄªÊî∂ÁõäÁéá: {metrics['total_return']:.2%}")
            print(f"üìä Âπ¥ÂåñÊî∂ÁõäÁéá: {metrics['annual_return']:.2%}")
            print(f"üìâ ÊúÄÂ§ßÂõûÊí§: {metrics['max_drawdown']:.2%}")
            print(f"üîÑ ‰∫§ÊòìÊ¨°Êï∞: {metrics['trade_count']} Á¨î")
            
            # ÁÆÄÂçïËØÑÁ∫ß
            if metrics['annual_return'] > 0.10:
                rating = "ËâØÂ•Ω üëç"
            elif metrics['annual_return'] > 0.05:
                rating = "‰∏ÄËà¨ üëå"
            else:
                rating = "ÈúÄË¶Å‰ºòÂåñ ü§î"
            
            print(f"üìã ÊµãËØïËØÑÁ∫ß: {rating}")
        else:
            print("‚ùå Êó†Ê≥ïËÆ°ÁÆóÊåáÊ†á")
        
        print("="*50)

# =============================================================================
# ‰∏ªÂáΩÊï∞
# =============================================================================

def quick_test():
    """Âø´ÈÄüÊµãËØï‰∏ªÂáΩÊï∞"""
    print("üß™ AËÇ°ÈáèÂåñÁ≥ªÁªü - Âø´ÈÄüÊµãËØï")
    print("="*40)
    print(f"üí∞ ÊµãËØïËµÑÈáë: {config.INITIAL_CAPITAL:,} ÂÖÉ") 
    print(f"üìÖ ÊµãËØïÂë®Êúü: {config.START_DATE} Ëá≥ {config.END_DATE}")
    print(f"üìä ÊµãËØïËÇ°Á•®: ÊúÄÂ§ö {config.TEST_STOCK_COUNT} Âè™")
    print(f"üîÑ Ë∞É‰ªìÈ¢ëÁéá: Â≠£Â∫¶")
    print("="*40)
    
    # Âä†ËΩΩÊµãËØïÊï∞ÊçÆ
    data_loader = QuickDataLoader(config)
    stock_pool, price_data = data_loader.load_test_data()
    
    if stock_pool is None or price_data is None:
        return False
    
    # ËøêË°åÂõûÊµã
    engine = QuickBacktestEngine(config)
    engine.run_backtest(stock_pool, price_data)
    
    # ÂàÜÊûêÁªìÊûú
    analyzer = QuickResultAnalyzer(engine)
    analyzer.print_summary()
    analyzer.plot_results()
    
    # ÊòæÁ§∫‰∫§ÊòìËÆ∞ÂΩï
    if engine.trades:
        print(f"\nüìã ‰∫§ÊòìËÆ∞ÂΩï:")
        trades_df = pd.DataFrame(engine.trades)
        for _, trade in trades_df.iterrows():
            action = "‰π∞ÂÖ•" if trade['action'] == 'buy' else "ÂçñÂá∫"
            print(f"  {trade['date']} {action} {trade['code']} "
                  f"{trade['shares']}ËÇ° @{trade['price']:.2f}ÂÖÉ")
    
    print(f"\n‚úÖ Âø´ÈÄüÊµãËØïÂÆåÊàêÔºÅ")
    print("üí° Â¶ÇÊûúÁªìÊûúÊª°ÊÑèÔºåÂèØ‰ª•ËøêË°åÂÆåÊï¥ÁâàÊú¨ÁöÑ main.py")
    return True

if __name__ == "__main__":
    quick_test()